# -*- coding: utf-8 -*-
# Form implementation generated from reading ui file 'AutoRegressionTestTool_ui.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import pandas as pd
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import *
from py_ssh import AutoRegressionTestTool_main
from time import sleep,strftime, localtime
import os
import queue


class Ui_Dialog(QtCore.QObject):
    clear_signal = QtCore.pyqtSignal()
    def __init__(self):
        super().__init__()
        self.sheet_name = ''
        self.cycle_time = 1

    def setupUi(self, Dialog):
        # 自动生成参数
        Dialog.setObjectName("Dialog")
        Dialog.setWindowModality(QtCore.Qt.WindowModal)
        Dialog.resize(1061, 809)
        Dialog.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))
        self.label = QtWidgets.QLabel(Dialog)
        self.label.setGeometry(QtCore.QRect(10, 110, 81, 16))
        self.label.setObjectName("label")
        self.label_2 = QtWidgets.QLabel(Dialog)
        self.label_2.setGeometry(QtCore.QRect(740, 110, 81, 16))
        self.label_2.setObjectName("label_2")
        self.label_3 = QtWidgets.QLabel(Dialog)
        self.label_3.setGeometry(QtCore.QRect(10, 10, 101, 16))
        self.label_3.setObjectName("label_3")
        self.pushButton_chosefile = QtWidgets.QPushButton(Dialog)
        self.pushButton_chosefile.setGeometry(QtCore.QRect(890, 30, 151, 31))
        self.pushButton_chosefile.setObjectName("pushButton_chosefile")
        self.splitter = QtWidgets.QSplitter(Dialog)
        self.splitter.setGeometry(QtCore.QRect(10, 70, 331, 31))
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setHandleWidth(60)
        self.splitter.setObjectName("splitter")
        self.pushButton_starttest = QtWidgets.QPushButton(self.splitter)
        self.pushButton_starttest.setObjectName("pushButton_starttest")
        self.pushButton_stoptest = QtWidgets.QPushButton(self.splitter)
        self.pushButton_stoptest.setObjectName("pushButton_stoptest")
        self.lineEdit = QtWidgets.QLineEdit(Dialog)
        self.lineEdit.setGeometry(QtCore.QRect(10, 30, 661, 31))
        self.lineEdit.setObjectName("lineEdit")
        self.listWidget = QtWidgets.QListWidget(Dialog)
        self.listWidget.setGeometry(QtCore.QRect(740, 130, 311, 641))
        self.listWidget.setObjectName("listWidget")
        self.textBrowser = QtWidgets.QTextBrowser(Dialog)
        self.textBrowser.setGeometry(QtCore.QRect(10, 130, 711, 641))
        self.textBrowser.setObjectName("textBrowser")
        self.comboBox = QtWidgets.QComboBox(Dialog)
        self.comboBox.setGeometry(QtCore.QRect(690, 30, 181, 31))
        self.comboBox.setObjectName("comboBox")
        self.radioButton = QtWidgets.QRadioButton(Dialog)
        self.radioButton.setGeometry(QtCore.QRect(750, 80, 89, 16))
        self.radioButton.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.radioButton.setObjectName("radioButton")
        self.lineEdit_2 = QtWidgets.QLineEdit(Dialog)
        self.lineEdit_2.setGeometry(QtCore.QRect(910, 70, 131, 31))
        self.lineEdit_2.setObjectName("lineEdit_2")
        self.label_4 = QtWidgets.QLabel(Dialog)
        self.label_4.setGeometry(QtCore.QRect(850, 80, 81, 16))
        self.label_4.setObjectName("label_5")
        self.label_5 = QtWidgets.QLabel(Dialog)
        self.label_5.setGeometry(QtCore.QRect(480, 80, 81, 16))
        self.label_5.setObjectName("label_5")
        self.lineEdit_5 = QtWidgets.QLineEdit(Dialog)
        self.lineEdit_5.setGeometry(QtCore.QRect(540, 70, 131, 31))
        self.lineEdit_5.setObjectName("lineEdit_2")
        self.label_6 = QtWidgets.QLabel(Dialog)
        self.label_6.setGeometry(QtCore.QRect(680, 80, 81, 16))
        self.label_6.setObjectName("label_6")

        self.comboBox.setEnabled(False)
        self.pushButton_stoptest.setEnabled(False)
        self.pushButton_starttest.setEnabled(False)

        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

        # 按键功能
        self.pushButton_chosefile.clicked.connect(self.chose_file)
        self.pushButton_starttest.clicked.connect(self.start_test)
        self.pushButton_stoptest.clicked.connect(self.stop_test)
        # 增加一个延时开始测试的功能，输入框输入数字，单位分，勾选后生效

        # 获取下拉列表活动状态
        self.comboBox.currentIndexChanged[str].connect(self.sheet_value)
        # 获取屏幕分辨率
        screen = QtWidgets.QApplication.primaryScreen()
        screen_size = screen.size()
        width = screen_size.width()
        height = screen_size.height()

        # 设置窗口大小为屏幕的一半
        # Dialog.resize(width // 2, height // 2)
    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "自动测试平台v2.0.2"))
        self.label.setText(_translate("Dialog", "运行记录"))
        self.label_2.setText(_translate("Dialog", "已执行内容"))
        self.label_3.setText(_translate("Dialog", "选择测试用例"))
        self.pushButton_chosefile.setText(_translate("Dialog", "选择测试用例"))
        self.pushButton_starttest.setText(_translate("Dialog", "开始执行"))
        self.pushButton_stoptest.setText(_translate("Dialog", "停止执行"))
        self.radioButton.setText(_translate("Dialog", "重复测试"))
        self.label_4.setText(_translate("Dialog", "重复次数"))
        self.label_5.setText(_translate("Dialog", "延时开始"))
        self.label_6.setText(_translate("Dialog", "分钟"))

    def chose_file(self):
        title = "选择用例表格"  # 对话框标题
        self.set_item_flase()
        self.listWidget.clear()

        try:
            self.filename = QtWidgets.QFileDialog.getOpenFileName(caption=title)[0]
            self.lineEdit.setText(self.filename)
            self.comboBox.clear()
            self.comboBox.setEnabled(True)
            sheet_list = list(pd.read_excel(self.filename, sheet_name=None))
            for i in sheet_list:
                self.comboBox.addItem(i)
        except Exception as error:
            print(error)
            self.comboBox.addItem('用例异常')
            pass
        self.set_item_true()

    def start_test(self):
        # 生成消息队列
        self.msg_queue = queue.Queue()
        self.status_queue = queue.Queue()
        self.pushButton_starttest.setEnabled(False)
        self.pushButton_stoptest.setEnabled(True)
        self.delay_time = 0
        # 拆分成两个函数，一个单次 一个循环？
        if self.lineEdit.text() == '':
            pass
        else:
            # 生成log和report文件夹
            # 改一下放到AutoRegressionTestTool_test里面，让每次跑都生成一个新的log
            if not os.path.exists(os.path.join("./", 'log')):  # 判断log文件夹是否存在
                os.makedirs(os.path.join("./", 'log')) # 不存在则创建
            else:
                print('The log directory already exists.')
            if not os.path.exists(os.path.join("./", 'report')):
                os.makedirs(os.path.join("./", 'report'))
            else:
                print('The report directory already exists.')

            sleep(0.01)
            self.set_item_flase()
            start_time = strftime("%Y-%m-%d %H-%M-%S", localtime())
            file = os.path.basename(self.filename).split('.')[0] + start_time
            self.log = open('./log/' + file + '.log', '+a', encoding='utf-8')
            self.case_read()
            self.textBrowser.clear()
            self.listWidget.clear()

            self.running_log_thread = RunningLogThread(self, self.msg_queue)
            self.test_status_thread = TestStatusThread(self, self.status_queue)

            # 启动线程
            self.running_log_thread.start()
            self.test_status_thread.start()

            self.status_queue.put('UI_START_FLAG')

            if self.lineEdit_5.text() != '':
                self.delay_time = int(self.lineEdit_5.text())

            # 重复测试部分功能
            if self.radioButton.isChecked():
                if self.lineEdit_2.text() != '':
                    self.cycle_time = int(self.lineEdit_2.text())
                else:
                    self.cycle_time = -1
            else:
                self.cycle_time = 1
            self.test = AutoRegressionTestTool_main.TestPerform(self.filename, self.sheet_name, self.cycle_time, self.msg_queue, self.status_queue, self.delay_time,self.test_data_dict,self.case_index, self.case_step_dict)
            self.start_ = TestThread(self.test)
            self.start_.start()
            
    def stop_test(self):
        self.pushButton_stoptest.setEnabled(False)
        self.test.close_all_ssh()
        self.start_.terminate()
        self.running_log_thread.terminate()
        self.test_status_thread.terminate()
        if self.lineEdit.text() == '':
            pass
        elif self.start_.isRunning():
            if self.running_log_thread.isRunning():
                self.status_queue.put('UI_STOP_FLAG')
                self.test.test_done_flag()
        else:
            self.status_queue.put('UI_STOP_FLAG')
            self.test.test_done_flag()
        self.set_item_true()
        try:
            self.log.close()
        except ValueError as e:
            print(e)
        self.msg_queue.queue.clear()
        self.status_queue.queue.clear()
        sleep(1)

    # 获取下拉列表活动状态
    def sheet_value(self, sheet):
        self.sheet_name = sheet

    def case_read(self):
        """
        读取用例内容  用例名  用例步骤  用例内容
        """
        self.test_data_dict = {}
        self.case_index = []
        self.case_step_dict = {}
        try:
            df = pd.read_excel(self.filename, sheet_name=self.sheet_name)
        except ValueError as error:
            self.msg_queue.put('用例表格异常，请检查！\n')
            self.msg_queue.put(error)
            self.status_queue.put('TEST_FAIL_FLAG')
            return
        for i in df.index.values:  # 获取行号的索引，并对其进行遍历：   # 用例步骤有重复内容的话会有异常，但目前没有出现报错
            try:
                # 根据i来获取每一行指定的数据 并利用to_dict转成字典
                read_case = df.loc[i, ['用例名', ]].to_list()
                read_step = df.loc[i, ['步骤', ]].to_list()
                content = df.loc[
                    i, ['说明', '服务器', '用户名', '密码', '发送命令', '发送模式', '等待回显', '刷新间隔',
                        '超时时间', '失败回显', '连接复用']].to_dict()
                # case名称做键，step做值，剩下的东西做step里的子键值
                try:
                    self.test_data_dict[read_case[0]][read_step[0]] = content
                except KeyError:
                    self.test_data_dict[read_case[0]] = {read_step[0]: content}
                # 按表格顺序获取case,去掉重复case,作为case索引 case_index
                if read_case[0] not in self.case_index:
                    self.case_index.append(read_case[0])
                # step字典,case_step_dict
                try:
                    self.case_step_dict[read_case[0]].append(read_step[0])
                except KeyError:
                    self.case_step_dict[read_case[0]] = [read_step[0]]
            except KeyError as KeyError_msg:
                self.msg_queue.put('用例表格内容有误，请检查！\n')
                self.msg_queue.put(KeyError_msg)
                self.status_queue.put('TEST_FAIL_FLAG')
                break
        # 创建一个带表头的全局xlsx
        # self.df = pd.DataFrame({'test_case', 'test_step', 'test_result','test_comments'})
        # 还要一个计数，行的计数,从1开始，不算表头
        # self.df_row = 1

    def set_item_flase(self):
        self.pushButton_starttest.setEnabled(False)
        self.pushButton_chosefile.setEnabled(False)
        self.radioButton.setEnabled(False)
        self.lineEdit.setEnabled(False)
        self.lineEdit_2.setEnabled(False)
        self.comboBox.setEnabled(False)
        self.listWidget.setEnabled(False)
        self.lineEdit_5.setEnabled(False)

    def set_item_true(self):
        self.pushButton_starttest.setEnabled(True)
        self.pushButton_chosefile.setEnabled(True)
        self.radioButton.setEnabled(True)
        self.lineEdit.setEnabled(True)
        self.lineEdit_2.setEnabled(True)
        self.comboBox.setEnabled(True)
        self.listWidget.setEnabled(True)
        self.lineEdit_5.setEnabled(True)


class TestThread(QtCore.QThread):
    def __init__(self, test):
        QtCore.QThread.__init__(self)
        self.test = test

    def run(self):
        self.test.case_run()


class RunningLogThread(QtCore.QThread):
    append_signal = QtCore.pyqtSignal(str)
    append_mv = QtCore.pyqtSignal()

    def __init__(self, ui, msg_queue):
        super().__init__()
        self.ui = ui
        self.msg_queue = msg_queue
        self.append_signal.connect(self.ui.textBrowser.append)
        self.append_mv.connect(self.move_cursor_to_end)

    def move_cursor_to_end(self):
        cursor = self.ui.textBrowser.textCursor()
        cursor.movePosition(QtGui.QTextCursor.End)
        self.ui.textBrowser.setTextCursor(cursor)

    def run(self):
        self.running_log()

    def running_log(self):
        queue_log_tail = ''
        lines_count = 0
        while True:
            try:
                # 减少资源占用
                queue_log = queue_log_tail + self.msg_queue.get()
                if lines_count > 10000:
                    self.ui.clear_signal.emit()
                    lines_count = 0
                lines_count += len(queue_log.split('\n'))
                if queue_log[-1:] != '\n':
                    last_newline_index = queue_log.rfind('\n')
                    queue_log_tail = queue_log[last_newline_index + 1:]
                    queue_log = queue_log[:last_newline_index + 1]
                else:
                    queue_log_tail = ''
                self.append_signal.emit(queue_log)
                self.append_mv.emit()
                self.ui.log.write(queue_log)
            except ValueError as error:
                print('running_log error:')
                print(error)
                break
            except EOFError as error:
                print(error)
                break
            except TypeError as error:
                print(error)
                print('probably cmd str error!')
                continue


class TestStatusThread(QtCore.QThread):
    def __init__(self, ui, status_queue):
        super().__init__()
        self.ui = ui
        self.status_queue = status_queue

    def run(self):
        self.test_status()

    def test_status(self):
        while True:
            try:
                queue_status = self.status_queue.get()
                # 测试状态标志
                if queue_status == 'UI_START_FLAG':
                    print('UI_START_FLAG')
                elif queue_status == 'UI_STOP_FLAG':
                    print('UI_STOP_FLAG')
                # 后面环境因素或者奇怪的跑脚本失败要做新的处理，目前暂时跟测试完成一样处理
                elif queue_status == 'TEST_FAIL_FLAG':
                    print('TEST_FAIL_FLAG')
                    self.ui.stop_test()
                elif queue_status == 'TEST_FINISH_FLAG':
                    print('TEST_FINISH_FLAG')
                    # self.ui.stop_test()
                    sleep(1)
                    self.ui.set_item_true()
                else:
                    index = self.ui.listWidget.currentRow() + 1
                    self.ui.listWidget.addItem(queue_status)
                    if 'pass' in queue_status:
                        self.ui.listWidget.item(index).setBackground(QColor('#7FFF11'))
                    elif 'fail' in queue_status:
                        self.ui.listWidget.item(index).setBackground(QColor('red'))
                    self.ui.listWidget.setCurrentRow(self.ui.listWidget.currentRow()+1)
                    self.ui.log.write('')
            except ValueError as error:
                print('test_status error:')
                print(error)  # 用来停打印
                break
