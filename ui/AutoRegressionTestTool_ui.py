# -*- coding: utf-8 -*-
# Form implementation generated from reading ui file 'AutoRegressionTestTool_ui.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import time

from openpyxl import load_workbook, Workbook
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import *
from PyQt5.QtCore import pyqtSignal, QObject
from py_ssh import AutoRegressionTestTool_main
from time import strftime, localtime
import os
import queue


class Ui_Dialog(QtCore.QObject):
    clear_signal = QtCore.pyqtSignal()
    stop_test_signal = pyqtSignal()
    def __init__(self):
        super().__init__()
        self.sheet_name = ''
        self.cycle_time = 1
        self.stop_test_signal.connect(self.stop_test)

    def setupUi(self, Dialog):
        # 自动生成参数
        Dialog.setObjectName("Dialog")
        Dialog.setWindowModality(QtCore.Qt.WindowModal)
        Dialog.resize(1061, 868)
        Dialog.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))
        self.label = QtWidgets.QLabel(Dialog)
        self.label.setGeometry(QtCore.QRect(10, 148, 81, 16))
        self.label.setObjectName("label")
        self.label_2 = QtWidgets.QLabel(Dialog)
        self.label_2.setGeometry(QtCore.QRect(740, 148, 81, 16))
        self.label_2.setObjectName("label_2")
        self.label_3 = QtWidgets.QLabel(Dialog)
        self.label_3.setGeometry(QtCore.QRect(10, 10, 101, 16))
        self.label_3.setObjectName("label_3")
        self.pushButton_chosefile = QtWidgets.QPushButton(Dialog)
        self.pushButton_chosefile.setGeometry(QtCore.QRect(890, 30, 151, 31))
        self.pushButton_chosefile.setObjectName("pushButton_chosefile")
        self.splitter = QtWidgets.QSplitter(Dialog)
        self.splitter.setGeometry(QtCore.QRect(10, 70, 321, 31))
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setHandleWidth(20)
        self.splitter.setObjectName("splitter")
        self.pushButton_starttest = QtWidgets.QPushButton(self.splitter)
        self.pushButton_starttest.setObjectName("pushButton_starttest")
        self.pushButton_stoptest = QtWidgets.QPushButton(self.splitter)
        self.pushButton_stoptest.setObjectName("pushButton_stoptest")
        self.lineEdit_excelname = QtWidgets.QLineEdit(Dialog)
        self.lineEdit_excelname.setGeometry(QtCore.QRect(10, 30, 661, 31))
        self.lineEdit_excelname.setObjectName("lineEdit")
        self.listWidget = QtWidgets.QListWidget(Dialog)
        self.listWidget.setGeometry(QtCore.QRect(740, 168, 311, 641))
        self.listWidget.setObjectName("listWidget")
        self.textBrowser = QtWidgets.QTextBrowser(Dialog)
        self.textBrowser.setGeometry(QtCore.QRect(10, 168, 711, 641))
        self.textBrowser.setObjectName("textBrowser")
        self.comboBox = QtWidgets.QComboBox(Dialog)
        self.comboBox.setGeometry(QtCore.QRect(690, 30, 181, 31))
        self.comboBox.setObjectName("comboBox")
        self.CheckButton_retest = QtWidgets.QCheckBox(Dialog)
        self.CheckButton_retest.setGeometry(QtCore.QRect(837, 80, 89, 16))
        self.CheckButton_retest.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.CheckButton_retest.setObjectName("radioButton")
        self.lineEdit_2 = QtWidgets.QLineEdit(Dialog)
        self.lineEdit_2.setGeometry(QtCore.QRect(980, 70, 61, 31))
        self.lineEdit_2.setObjectName("lineEdit_2")
        self.label_4 = QtWidgets.QLabel(Dialog)
        self.label_4.setGeometry(QtCore.QRect(930, 80, 81, 16))
        self.label_4.setObjectName("label_5")
        self.label_5 = QtWidgets.QLabel(Dialog)
        self.label_5.setGeometry(QtCore.QRect(695, 80, 81, 16))
        self.label_5.setObjectName("label_5")
        self.lineEdit_5 = QtWidgets.QLineEdit(Dialog)
        self.lineEdit_5.setGeometry(QtCore.QRect(725, 70, 61, 31))
        self.lineEdit_5.setObjectName("lineEdit_2")
        self.label_6 = QtWidgets.QLabel(Dialog)
        self.label_6.setGeometry(QtCore.QRect(790, 80, 81, 16))
        self.label_6.setObjectName("label_6")
        # 失败退出
        self.CheckButton_fstop = QtWidgets.QCheckBox(Dialog)
        self.CheckButton_fstop.setGeometry(QtCore.QRect(740, 120, 68, 16))
        self.CheckButton_fstop.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.CheckButton_fstop.setObjectName("CheckButton_fstop")
        # 生成html报告
        self.CheckButton_html = QtWidgets.QCheckBox(Dialog)
        self.CheckButton_html.setGeometry(QtCore.QRect(827, 120, 99, 16))
        self.CheckButton_html.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.CheckButton_html.setObjectName("CheckButton_html")
        # 生成excel报告
        self.CheckButton_excel = QtWidgets.QCheckBox(Dialog)
        self.CheckButton_excel.setGeometry(QtCore.QRect(936, 120, 105, 16))
        self.CheckButton_excel.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.CheckButton_excel.setObjectName("CheckButton_excel")

        self.comboBox.setEnabled(False)
        self.pushButton_stoptest.setEnabled(False)
        self.pushButton_starttest.setEnabled(False)

        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

        # 按键功能
        self.pushButton_chosefile.clicked.connect(self.chose_file)
        self.pushButton_starttest.clicked.connect(self.start_test)
        self.pushButton_stoptest.clicked.connect(self.stop_test)
        # 勾选功能
        # self.CheckButton_fstop.stateChanged.connect(lambda state: self.on_checkBox_stateChanged(state, "CheckButton_fstop"))
        # self.CheckButton_html.stateChanged.connect(lambda state: self.on_checkBox_stateChanged(state, "CheckButton_html"))
        # self.CheckButton_excel.stateChanged.connect(lambda state: self.on_checkBox_stateChanged(state, "CheckButton_excel"))

        # 增加一个延时开始测试的功能，输入框输入数字，单位分，勾选后生效

        # 获取下拉列表活动状态
        self.comboBox.currentIndexChanged[str].connect(self.sheet_value)
        # 获取屏幕分辨率
        screen = QtWidgets.QApplication.primaryScreen()
        screen_size = screen.size()
        width = screen_size.width()
        height = screen_size.height()

        # 设置窗口大小为屏幕的一半
        # Dialog.resize(width // 2, height // 2)
    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "自动测试平台v2.0.3"))
        self.label.setText(_translate("Dialog", "运行记录"))
        self.label_2.setText(_translate("Dialog", "运行状态"))
        self.label_3.setText(_translate("Dialog", "选择测试用例"))
        self.pushButton_chosefile.setText(_translate("Dialog", "选择测试用例"))
        self.pushButton_starttest.setText(_translate("Dialog", "开始执行"))
        self.pushButton_stoptest.setText(_translate("Dialog", "停止执行"))
        self.CheckButton_retest.setText(_translate("Dialog", "重复测试"))
        self.label_4.setText(_translate("Dialog", "重复次数"))
        self.label_5.setText(_translate("Dialog", "延时"))
        self.label_6.setText(_translate("Dialog", "分钟开始"))
        self.CheckButton_fstop.setText(_translate("Dialog", "失败停止"))
        self.CheckButton_html.setText(_translate("Dialog", "生成html报告"))
        self.CheckButton_excel.setText(_translate("Dialog", "生成excel报告"))

    def chose_file(self):
        title = "选择用例表格"  # 对话框标题
        self.set_item_flase()
        self.listWidget.clear()

        try:
            self.filename = QtWidgets.QFileDialog.getOpenFileName(caption=title)[0]
            self.lineEdit_excelname.setText(self.filename)
            self.comboBox.clear()
            self.comboBox.setEnabled(True)
            self.xlsx = load_workbook(self.filename)
            sheet_list = self.xlsx.sheetnames
            for i in sheet_list:
                self.comboBox.addItem(i)
        except Exception as error:
            print(error)
            self.comboBox.addItem('用例异常')
            pass
        self.set_item_true()

    def start_test(self):
        # 生成消息队列
        self.msg_queue = queue.Queue()
        self.status_queue = queue.Queue()
        self.pushButton_starttest.setEnabled(False)
        self.pushButton_stoptest.setEnabled(True)
        self.delay_time = 0
        # 拆分成两个函数，一个单次 一个循环？
        self.clear_signal.connect(self.textBrowser.clear)
        if self.lineEdit_excelname.text() == '':
            pass
        else:
            # 生成log和report文件夹
            # 改一下放到AutoRegressionTestTool_test里面，让每次跑都生成一个新的log
            if not os.path.exists(os.path.join("./", 'log')):  # 判断log文件夹是否存在
                os.makedirs(os.path.join("./", 'log')) # 不存在则创建
            if not os.path.exists(os.path.join("./", 'report')):
                os.makedirs(os.path.join("./", 'report'))
            self.set_item_flase()
            start_time = strftime("%Y-%m-%d %H-%M-%S", localtime())
            file = os.path.basename(self.filename).split('.')[0] + start_time
            self.log = open('./log/' + file + '.log', '+a', encoding='utf-8')
            self.case_read()
            self.textBrowser.clear()
            self.listWidget.clear()

            self.running_log_thread = RunningLogThread(self, self.msg_queue)
            self.test_status_thread = TestStatusThread(self, self.status_queue)

            # 启动线程
            self.running_log_thread.start()
            self.test_status_thread.start()

            self.status_queue.put('UI_START_FLAG')

            if self.lineEdit_5.text() != '':
                self.delay_time = int(self.lineEdit_5.text())

            # 重复测试部分功能
            if self.CheckButton_retest.isChecked():
                if self.lineEdit_2.text() != '':
                    self.cycle_time = int(self.lineEdit_2.text())
                else:
                    self.cycle_time = -1
            else:
                self.cycle_time = 1
            self.test = AutoRegressionTestTool_main.TestPerform(self.filename, self.sheet_name, self.cycle_time, self.msg_queue, self.status_queue, self.delay_time,self.test_data_dict,self.case_index, self.case_step_dict)
            self.start_ = TestThread(self.test)
            self.start_.start()
            
    def stop_test(self):
        self.pushButton_stoptest.setEnabled(False)
        self.test.close_all_ssh()
        self.start_.terminate()
        self.running_log_thread.terminate()
        self.test_status_thread.terminate()
        QtCore.QThread.sleep(1)
        if self.lineEdit_excelname.text() == '':
            pass
        elif self.start_.isRunning():
            if self.running_log_thread.isRunning():
                self.status_queue.put('UI_STOP_FLAG')
                self.test.test_done_flag()
        else:
            self.status_queue.put('UI_STOP_FLAG')
            self.test.test_done_flag()
        self.set_item_true()
        try:
            self.log.close()
        except ValueError as e:
            print('log close error')
            print(e)

        self.msg_queue.queue.clear()
        self.status_queue.queue.clear()
        self.log.close()

        # 如果选择了生成html报告就什么都不做，如果没有选择就删除生成的html报告
        if not self.CheckButton_html.isChecked():
            try:
                os.remove('./report/' + os.path.basename(self.filename).split('.')[0] + '.html')
            except FileNotFoundError as e:
                print('html文件不存在')
        # 如果选择了生成excel报告就什么都不做，如果没有选择就删除生成的excel报告
        if not self.CheckButton_excel.isChecked():
            try:
                os.remove('./report/' + os.path.basename(self.filename).split('.')[0] + '.xlsx')
            except FileNotFoundError as e:
                print('excel文件不存在')

        QtCore.QThread.sleep(1)

    # 获取下拉列表活动状态
    def sheet_value(self, sheet):
        self.sheet_name = sheet

    def case_read(self):
        """
        读取用例内容  用例名  用例步骤  用例内容
        """
        self.test_data_dict = {}
        self.case_index = []
        self.case_step_dict = {}
        try:
            df = self.xlsx[self.sheet_name]
        except ValueError as error:
            self.msg_queue.put('用例表格异常，请检查！\n')
            self.msg_queue.put(error)
            self.status_queue.put('TEST_FAIL_FLAG')
            return
        # 获取表头并过滤掉None值
        headers = [cell.value for cell in df[1] if cell.value is not None]
        data = []
        for row in df.iter_rows(min_row=2, values_only=True):
            row_dict = dict(zip(headers, row))
            row_dict = self.remove_none_from_dict(row_dict)  # 过滤掉None值
            data.append(row_dict)
            case_name = row[headers.index('用例名')]
            case_step = row[headers.index('步骤')]
            try:
                self.test_data_dict[case_name][case_step] = row_dict
            except KeyError:
                self.test_data_dict[case_name] = {case_step: row_dict}
            if case_name not in self.case_index and case_name is not None:
                self.case_index.append(case_name)
            try:
                self.case_step_dict[case_name].append(case_step)
            except KeyError:
                self.case_step_dict[case_name] = [case_step]

    @staticmethod
    def remove_none_from_dict(row):
        return {k: v for k, v in row.items() if v is not None}

    def set_item_flase(self):
        self.pushButton_starttest.setEnabled(False)
        self.pushButton_chosefile.setEnabled(False)
        self.CheckButton_retest.setEnabled(False)
        self.lineEdit_excelname.setEnabled(False)
        self.lineEdit_2.setEnabled(False)
        self.comboBox.setEnabled(False)
        self.listWidget.setEnabled(False)
        self.lineEdit_5.setEnabled(False)
        self.CheckButton_fstop.setEnabled(False)
        self.CheckButton_html.setEnabled(False)
        self.CheckButton_excel.setEnabled(False)

    def set_item_true(self):
        self.pushButton_starttest.setEnabled(True)
        self.pushButton_chosefile.setEnabled(True)
        self.CheckButton_retest.setEnabled(True)
        self.lineEdit_excelname.setEnabled(True)
        self.lineEdit_2.setEnabled(True)
        self.comboBox.setEnabled(True)
        self.listWidget.setEnabled(True)
        self.lineEdit_5.setEnabled(True)
        self.CheckButton_fstop.setEnabled(True)
        self.CheckButton_html.setEnabled(True)
        self.CheckButton_excel.setEnabled(True)

    # def on_checkBox_stateChanged(self, state, checkBoxName):
    #     if state == QtCore.Qt.Checked:
    #         print(f"{checkBoxName} is checked")
    #     else:
    #         print(f"{checkBoxName} is not checked")


class TestThread(QtCore.QThread):
    def __init__(self, test):
        QtCore.QThread.__init__(self)
        self.test = test

    def run(self):
        self.test.case_run()


class RunningLogThread(QtCore.QThread):
    append_signal = QtCore.pyqtSignal(str)
    append_mv = QtCore.pyqtSignal()

    def __init__(self, ui, msg_queue):
        super().__init__()
        self.ui = ui
        self.msg_queue = msg_queue
        self.append_signal.connect(self.ui.textBrowser.append)
        self.append_mv.connect(self.move_cursor_to_end)

    def move_cursor_to_end(self):
        cursor = self.ui.textBrowser.textCursor()
        cursor.movePosition(QtGui.QTextCursor.End)
        self.ui.textBrowser.setTextCursor(cursor)

    def run(self):
        self.running_log()

    def running_log(self):
        queue_log_tail = ''
        lines_count = 0
        total_data_size = 0
        while True:
            try:
                # 减少资源占用
                queue_log = queue_log_tail + self.msg_queue.get()
                total_data_size += len(queue_log.encode('utf-8'))
                if total_data_size > 10480000:  # 如果接收到的数据的总大小已经达到10MB
                    self.ui.clear_signal.emit()  # 清空窗口
                    total_data_size = 0  # 重置接收到的数据的总大小
                # if lines_count > 10000:
                #     self.ui.clear_signal.emit()
                #     lines_count = 0
                # lines_count += len(queue_log.split('\n'))
                if queue_log[-1:] != '\n':
                    last_newline_index = queue_log.rfind('\n')
                    queue_log_tail = queue_log[last_newline_index + 1:]
                    queue_log = queue_log[:last_newline_index + 1]
                else:
                    queue_log_tail = ''
                self.append_signal.emit(queue_log)
                self.append_mv.emit()
                self.ui.log.write(queue_log)
            except ValueError as error:
                print('running_log error:')
                print(error)
                break
            except EOFError as error:
                print('EOFError:')
                print(error)
                break
            except TypeError as error:
                print(error)
                print('probably cmd str error!')
                continue


class TestStatusThread(QtCore.QThread):
    scroll_to_bottom = QtCore.pyqtSignal()
    listWidget_clear = QtCore.pyqtSignal()
    generate_html_report = QtCore.pyqtSignal()
    generate_excel_report = QtCore.pyqtSignal()

    def __init__(self, ui, status_queue):
        super().__init__()
        self.ui = ui
        self.status_queue = status_queue

        # 连接信号到槽函数
        self.scroll_to_bottom.connect(self.ui.listWidget.scrollToBottom)
        self.listWidget_clear.connect(self.ui.listWidget.clear)
        self.generate_html_report.connect(self.generate_html_report_handler)
        self.generate_excel_report.connect(self.generate_excel_report_handler)

        # 连接复选框的 stateChanged 信号到槽函数
        self.ui.CheckButton_html.stateChanged.connect(self.on_checkBox_html_stateChanged)
        self.ui.CheckButton_excel.stateChanged.connect(self.on_checkBox_excel_stateChanged)

        # # 检查复选框状态并发射相应的信号
        # if self.ui.CheckButton_html.isChecked():
        #     self.generate_html_report.emit()
        # if self.ui.CheckButton_excel.isChecked():
        #     self.generate_excel_report.emit()

    def on_checkBox_html_stateChanged(self, state):
        if state == QtCore.Qt.Checked:
            self.generate_html_report.emit()

    def on_checkBox_excel_stateChanged(self, state):
        if state == QtCore.Qt.Checked:
            self.generate_excel_report.emit()

    def generate_html_report_handler(self):
        print('生成html报告')

    def generate_excel_report_handler(self):
        print('生成excel报告')
    def run(self):
        self.test_status()

    def test_status(self):
        index = 0
        case_count = 0
        print(self.ui.filename)
        print(self.ui.sheet_name)
        while True:
            try:
                queue_status = self.status_queue.get()
                print(queue_status)
                # 测试状态标志
                if queue_status == 'UI_START_FLAG':
                    print('UI_START_FLAG')
                    pass
                elif queue_status == 'UI_STOP_FLAG':
                    print('UI_STOP_FLAG')
                    pass
                # 后面环境因素或者奇怪的跑脚本失败要做新的处理，目前暂时跟测试完成一样处理
                elif queue_status == 'TEST_FAIL_FLAG':
                    print('TEST_FAIL_FLAG')
                    if self.ui.CheckButton_fstop.isChecked():
                        self.ui.stop_test_signal.emit()
                    pass
                elif queue_status == 'TEST_FINISH_FLAG':    # 测试执行完成
                    print('TEST_FINISH_FLAG')
                    self.ui.stop_test_signal.emit()
                    # self.ui.set_item_true()
                    pass
                elif queue_status == 'CASE_FINISH_FLAG':    # 单一用例执行完成,顺便作为清空list的计数标志
                    case_count += 1
                else:   # 步骤执行完成标志
                    if 'pass' in queue_status:
                        self.ui.listWidget.takeItem(index-1)
                        self.ui.listWidget.addItem(queue_status)
                        self.ui.listWidget.item(index-1).setBackground(QColor('#7FFF11'))
                        index -= 1
                    elif 'fail' in queue_status:
                        self.ui.listWidget.takeItem(index-1)
                        self.ui.listWidget.addItem(queue_status)
                        self.ui.listWidget.item(index-1).setBackground(QColor('red'))
                        index -= 1
                        if self.ui.CheckButton_fstop.isChecked():
                            self.ui.stop_test_signal.emit()
                    elif 'running' in queue_status:
                        self.ui.listWidget.addItem(queue_status)
                        self.ui.listWidget.item(index).setBackground(QColor('#FFFF00'))
                    else:
                        self.ui.listWidget.addItem(queue_status)
                    index += 1
                    # self.ui.listWidget.setCurrentRow(self.ui.listWidget.currentRow()+1)
                    self.scroll_to_bottom.emit()  # 发出信号
                    self.ui.log.write('')
                if case_count > 50:
                    # self.ui.listWidget.clear()
                    self.listWidget_clear.emit()
                    index = 0
                    case_count = 0
            except ValueError as error:
                print('test_status error:')
                print(error)  # 用来停打印
                break

    # 根据测试状态生成HTML测试报告
    def generate_html_report_s(self,test_results):
        html = "<html><body><table border='1'>"
        html += "<tr><th>Test Case</th><th>Status</th><th>Color</th></tr>"
        for index, result in enumerate(test_results, start=1):
            color = ""
            if 'pass' in result:
                color = "#7FFF11"
            elif 'fail' in result:
                color = "red"
            else:
                color = "white"
            html += f"<tr><td>Test Case {index}</td><td>{result}</td><td bgcolor='{color}'></td></tr>"
        html += "</table></body></html>"
        message = """
        <html>
        <head></head>
        <body>
        <p> </p>
        <p>测试用例&路径：%s</p>
        <p>测试用例表名：%s</p>
        <p> </p>
        <p> </p>
        <p>测试开始时间：%s</p>
        <p>测试结束时间：%s</p>
        <p> </p>
        <p> </p>
        <p>执行测试用例数：%s</p>
        <p>测试通过用例数：%s</p>
        <p>测试不通过用例数：%s</p>
        <p> </p>
        <p> </p>
        <p>测试用例执行状态：</p>
        </body>
        </html>
        """ % (self.ui.filename, self.ui.sheet_name,self.ui.start_time,self.ui.end_time,len(self.ui.case_result.keys()),'test_pass','test_fail')
        with open(self.ui.sheet_name + '_report.html', 'w') as f:
            f.write(html)
        f.close()

    # 根据测试状态生成excel测试报告
    def generate_excel_report_s(self,test_results):
        wb = Workbook()
        ws = wb.active
        ws.append(["Test Case", "Status"])
        for index, result in enumerate(test_results, start=1):
            ws.append([f"Test Case {index}", result])
        wb.save(self.ui.sheet_name + "_report.xlsx")

    # html = generate_html_report(test_results)
